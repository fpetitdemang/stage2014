%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amssymb}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \theoremstyle{definition}
 \newtheorem*{defn*}{\protect\definitionname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{graphicx}
\usepackage{listings}

\makeatother

\usepackage{babel}
  \providecommand{\definitionname}{Definition}

\begin{document}
%\pagenumbering{roman} \pagestyle{fancyplain} \thispagestyle{empty} \noindent \begin{center} \large{\texttt{Académie de Montpellier}}\\ \Large{\texttt{Université Montpellier II}}\\ \large{\texttt{Sciences et Techniques du Languedoc}}\\ \end{center}
\vspace{1cm}
\begin{center} \Huge{\textbf{Étude Bibliographique de Master 2\\}}  \vspace{1.0cm} %\Huge{\textbf{MASTER 2}} \normalsize \begin{center} \vspace{1.0cm} effectuée au Laboratoire d'Informatique de Robotique\\ et de Micro-électronique de Montpellier \end{center}
\vspace{2mm} %\Large{\textbf{franck PETITDEMANGE}}
\vspace{0.1cm} \normalsize
\vspace{3mm}
\large{Spécialité} : \textbf{AIGLE}\\ %\Large{Formation Doctorale} : \textbf{Informatique}\\ %\large{{\'E}cole Doctorale} : \textbf{Information, Structures, Systèmes} \vspace{1.0cm}
\LARGE{\textbf{Personnalisation de page web : application à l'amélioration de l'accessibilité du web}} \vspace{2mm}
\begin{center}   par \textbf{Franck~PETITDEMANGE} \end{center}
\vspace{2mm}
\vspace{4cm}
\textbf{Mars 2014}\\
\vspace{0.5cm}
Sous la direction de \textbf{Marianne~HUCHARD, Michel~MEYNARD, Yoann~BONAVERO}
\vspace{5mm}
%\begin{table}[hbt] %\begin{center} %\begin{tabular}{ l l l} %Messieurs & {\em } & Rapporteurs\\ %& {\em } & \\ %& {\em } & \\ %\\ %Messieurs& {\em } & Examinateurs \\ %& {\em } & \\ %& {\em } & \\ %\\ %Monsieur & {\em Evripidis BAMPIS} &  Directeur de thèse\\ %& {\em  X} & \\ %\end{tabular} %\end{center} %\end{table}
%\vspace{.7cm}
\end{center}
\newpage

\tableofcontents
\newpage


\section{Introduction et motivation}

Le world wild web (www) est un reseau de ressource. La publication
de ces ressources repose sur un langage universellement compréhensible
et accepté par tous les ordinateurs : HTML. Historiquement conçut
pour faciliter l'échange d'article dans la communauté scientifique.
La démocratisation du web a fait radicalement évoluer le contenu d'une
page web, sans pour autant que le langage ne suive ces évolutions.
Ainsi les auteurs de page web ont détourné les pratiques de conception
d'une page de manière anarchique. Ce manque d'homogénétité complique
la compréhension du contenu publié sur le www par une machine. Ceci
faisant perdre la propriété universelle du web voulu par son créateur
Tim Berners Lee : 
\begin{quotation}
``La puissance du Web réside dans son universalité. L'accès à tous,
quel que soit son handicap est un aspect essentiel'' 
\end{quotation}
Ceci introduit la motivation de ce stage et les problématiques qui
en découlent. 

Le sujet du stage est : la personnalisation des pages web. L'objectif
est de fournir des méthodes et des outils afin d'adapter une page
suivant les souhaits d'un lecteur. On s'interesse à une application
pour l'amélioration de l'accessibilité des pages web pour les personnes
en situation de handicap visuel. 

L'adaptation d'une page web implique notre problématique : la restructuration
d'une page web. On souhaite expérimenter une approche basée sur les
méta-modèles. L'idée étant d'extraire la structure d'une page et d'en
construire une représentation plus abstraite. Cela doit nous permettre
de s'affranchir de la diversité de conception de ces dernières. A
partir de cette représentation on veut lui appliquer des transformations,
puis générer une nouvelle page conforme aux transformations. 

Dans la section \ref{sec:Transformation-de-mod=0000E8le} nous décrivons
l'exploitation que nous souhaitons faire des modèles. En section \ref{sec:Modele-de-page}
nous étudions différents modèles de page en perspective de la création
d'un meta-modèle. Puis en section \ref{sec:Extraction-de-structure}
nous explorons différentes approches à l' extraction de la structure
d'une page web.

\newpage


\section{Exploitation des modèles\label{sec:Transformation-de-mod=0000E8le}}
\begin{defn*}
``Un modele est une description d'une partie d'un systeme écrit dans
un langage formel''\cite{Kleppe_et_al}

C'est une représentation simplifiée d'une partie d'un système, une
abstraction du système étudié suivant un point de vue. Par exemple
une carte routière est une abstraction d'un réseau routier, il existe
plusieurs types de carte suivant ce que l'on veut étudier (chemin
pédestre, chemin routier etc).\end{defn*}
\begin{quotation}
``Pour un observateur A, M est un modèle de l'objet O, si M aide
A à répondre aux questions qu'il pose sur O'' (Minsky) 
\end{quotation}
La notion de modèle fait référence à un langage formel definissant
les élements conceptuels du modèle : le méta-modèle. La syntaxe et
la sémantique du modèle sont conformes à un méta modèle.
\begin{defn*}
``Un méta-modèle est un modèle qui définit un langage formel pour
exprimer un modèle''\cite{Kleppe_et_al}
\end{defn*}
Littéralement, c'est un modèle de modèle.

~\\

Dans le cadre du sujet nous nous plaçons dans un contexte de restructuration
d'une page. On souhaite construire un modèle d'une page web à partir
de cette dernière. L'avantage est d'en manipuler une représentation
independante de la diversité de conception des pages. En effet les
élements, ou concepts, récurrents peuvent être structurés ou mises
en forme de manière différente d'une page web à l'autre. \cite{tichelaar2000famix}
présente une méthodologie similaire. Les auteurs souhaitent appliquer
des traitements homologues sur des systemes orientés objets implémentés
dans différentes plateformes (C++, Java, ADA, etc). Pour cela ils
ont réalisé un meta-modèle de systeme objet dans le but d'effectuer
des traitements independamment d'une representation sous-jacente. 

Nous voulons exploiter ce modèle de deux façons différentes. D'une
part ce modèle doit nous servir de support pour appliquer un processus
de transformation sur une page. Et d'autre part le modèle doit nous
servir de support à l'extraction des règles de transformation\emph{,
}que nous ne traiterons pas dans la bibliographie mais par la suite
dans le stage.
\begin{defn*}
``Une transformation est la génération automatique d'un modèle cible
depuis un modèle source selon une transformation définie''\cite{Kleppe_et_al} 

Une transformation est donc un ensemble de règles qui décrivent comment
un modèle du langage source peut être transformé dans un modèle du
langage cible. Plus précisement, elle est la description de comment
une ou plusieurs constructions d'un langage source peuvent être transformées
dans un langage cible. Plusieurs approches pour la transformation
de modèle existent \cite{czarnecki2003classification}. 

Suivant le langage du modèle source et du modèle cible, intervient
une distinction (fig.\ref{transfo_verticale_vs_horizontale}). On
parle de transformation endogène (rééchelonnement) lorsque les modèles
sont exprimés dans le même langage. On parle de transformation exogène
(translation) dans le cas contraire.

Il s'agit de transformation horizontale quand le modèle source et
cible possèdent le même niveau d'abstraction. Lorsque ce n'est pas
le cas, il s'agit de transformation verticale (fig.\ref{transfo_endogene_vs_exogene}).

\begin{figure}[H]
\centering
\includegraphics[width=300px]{img/transfo_verticale_vs_horizontale.jpg}

\caption{Transformation horizontale et verticale \label{transfo_verticale_vs_horizontale}}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=300px]{img/endogene_vs_exogene.jpg}

\caption{Transformation endogène et exogène \label{transfo_endogene_vs_exogene}}


\end{figure}


Il semble que notre processus de restructuration s'incrive dans le
cas d'une transformation endogène et horizontale (voir figure \ref{transfo_endogene}).
En effet, le modèle cible doit être conforme au méta-modèle et les
deux modèles (cibles et sources) ont le même niveau d'abstraction.
\end{defn*}
\begin{figure}[H]
\centering
\includegraphics[width=300px]{img/transformation_endogene_1.jpg}

\caption{Transformation endogène et horizontale \label{transfo_endogene}}
\end{figure}


\newpage


\section{Modele de page web\label{sec:Modele-de-page}}


\subsection{Introduction}

Comme expliqué dans la section \ref{sec:Transformation-de-mod=0000E8le},
le meta-modèle est le support à l'expression de transformation. Ainsi
les concepts décrits par le méta-modèle doivent comprendre les éléments,
ou concepts que l'on souhaite transformer dans une page. Par exemple,
si l'on souhaite modifier la couleur du texte de la bar de navigation,
on doit pouvoir exprimer dans la transformation le concept de bar
de navigation et le concept de couleur.

On s'interesse à la conception d'un meta-modèle proche de la vision
qu'un lecteur peut avoir d'une page. Le but étant d'exprimer des transformations
conformes aux souhaits du lecteur. On propose d'étudier et de comparer
le langage standard de publication de page sur le web, HTML, dans
la norme 4 et 5 mais aussi une toxonomie pour la description d'interface
graphique ARIA.


\subsection{HTML 4}

HTML 4 \cite{HTML_4} est un langage permettant la publication de
contenu sur le web. C'est le langage standard actuel des pages web.
Il permet de structurer le contenu et de lui associer une mise en
forme. Le contenu est organisé de manière hierarchique en le découpant
en section et sous-section. 


\paragraph{Structuration générique}

HTML 4 propose un mécanisme générique pour la composition de contenu
formant la structure des pages web. Ce mécanisme gravite autour des
éléments de type <DIV> leurs identifiants respectives : id et classe.


\subparagraph{DIV}

Signifiant division, est utilisé comme conteneur générique permettant
d'organiser le contenu. Il est exploité pour :
\begin{itemize}
\item regrouper les éléments pour leur appliquer un style (une mise en forme
particulière).
\item signaler une section ou une sous-section. 
\end{itemize}

\subparagraph{id et class}

Chaque élément peut se voir attribuer un identifiant ou une classe
d'appartenance. \emph{id} assigne un nom à un élément. Ce nom est
unique dans le document. \emph{class} au contraire, assigne un ou
plusieurs noms de classe à un élément. Un nom de classe peut être
partagé par plusieurs instances d'éléments. Les identifiants et les
classes sont des suites de caractères quelconque décidées arbitrairement
par l'auteur du document.

~\\

Les éléments DIV utilisés conjointement avec les attributs id et classe
sont au c½ur du mécanisme générique de structuration d'un document.
DIV permet de diviser le contenu d'un document en section et sous-section
(e.g figure \ref{div_sectionnement}) pour décrire sa structure. Les
éléments DIV ayant une sémantique neutre, c'est l'auteur du contenu
qui attribut (de manière arbitraire) un nom de \emph{class} ou un
\emph{id} (e.g figure \ref{div_role}). Le nom de \emph{class} ou
\emph{id} définissant un rôle au contenu ou une mise en forme. On
note le caractère implicite de la structuration.

\begin{figure}[H]
\begin{lstlisting}[frame=single, language=html]
<body>
	<div id="header" ></div>
	<div id="navigation_bar"><div/>
	<div id="main_content">
		<div class="article"></div>
		<div class="article"></div>
	</div>
	<div id="footer"></div>
</body>
\end{lstlisting}

\caption{Exemple d'attribution de rôle\label{div_role}}
\end{figure}


\begin{figure}[H]
\begin{lstlisting}[frame=single, language=html]
<body>
<div class="section" id="elephants-foret" > 
	<h1>Les éléphants des forêts</h1> 
	<p>Dans cette partie, nous abordons le sujet 
moins connu des éléphants des forêts.</p>
	<div class="sous-section" id="habitat-foret" > 
	<h2>L'habitat</h2> 
	<p>Les éléphants des forêts ne vivent pas 
dans les arbres mais au milieu d'eux.</p>
	</div> 
</div>
</body>
\end{lstlisting}

\caption{Exemple découpage en section et sous-section \label{div_sectionnement}}


\end{figure}


\begin{figure}[H]
\caption{Architecture page web HTML 4}


\centering
\includegraphics[width=300px]{img/architecture_Geekos_HTML4-294x300.jpg}

\end{figure}



\subsection{HTML 5}

HTML 5 \cite{HTML_5} étend HTML 4. La norme HTML 4 est toujours rétroactive.
HTML 5 remplace la structure générique de HTML 4 par un nouveau modèle.
Ce modèle amène de nouveaux élements qui apportent une sémantique
standard et explicite à la structure d'une page. 


\paragraph{Structuration }

Les nouveaux élements de HTML 5 spécifient donc une sémantique standard
:
\begin{itemize}
\item SECTION : représente une section générique dans un document, c'est
à dire un regroupement de contenu par thématique.
\item ARTICLE : représente un contenu autonome dans une page, facilite l'inclusion
de plusieurs sous documents.
\item NAV : représente une section de liens vers d'autres pages ou des fragments
de cette page.
\item ASIDE : représente une section de la page dont le contenu est indirectement
lié à ce qui l'entoure et qui pourrait être séparé de cet environnement.
\item HEADER : représente un groupe d'introduction ou une aide à la navigation.
Il peut contenir des éléments de titre, mais aussi d'autres éléments
tels qu'un logo, un formulaire de recherche, etc.
\item FOOTER : représente le pied de page, ou de la section, ou de la racine
de sectionnement la plus proche.
\end{itemize}
La figure \ref{html5_role} montre un découpage explicite de la structure
avec HTML 5 à contrario du découpage implicite de HTML 4 montré dans
la figure \ref{div_role}

\begin{figure}[H]
\begin{lstlisting}[frame=single, language=html]
<body>
	<header></header>
	<nav></nav>
	<section>
		<article></article>
		<article></article>
	</section>
	<footer></footer>
</body>
\end{lstlisting}

\caption{Exemple d'attribution de rôle\label{html5_role}}
\end{figure}
\begin{figure}[H]


\caption{Architecture HTML 5}


\centering
\includegraphics[width=300px]{img/architecture_Geekos_HTML5-293x300.jpg}

\end{figure}



\subsection{ARIA}

ARIA (Acessible Rich Internet Application) \cite{ARIA} est la spécification
d'une ontologie décrivant une interface graphique. Elle fournit des
informations sur la structuration d'un document et plus généralement
décrit les élements qui composent une interface au moyen d'un ensemble
de rôles, d'états et de propriétés .


\paragraph{Rôle }

Les rôles permettent d'identifier la fonction de chaque élément d'une
interface. Ils sont regroupés en trois catégories :
\begin{itemize}
\item Widget Roles : référence un ensemble de widget préfinis (alertdialog,
button, slider, scrollbar, menu, etc)
\item Document Structure Roles : décrit les structures qui organisent un
document (article, definition, entête, ect)
\item Landmark Roles : décrit les régions principales d'une interface graphique
(main, navigation, search, etc)
\end{itemize}

\paragraph{Etats et propriétés}

ARIA prend en compte l'aspect dynamique et interactif des éléments
d'une interface. Elle permet d'associer des états et des propriétés
aux éléments graphiques. Un état est une configuration unique d'un
objet. Par exemple, on peut définir l'état d'un bouton par l'état
\emph{aria-checked }qui peut prendre trois propriétés suivant l'interaction
avec l'utilisateur : \emph{true - false - mixed} . Aria prévoit même
un systeme d'annotation pour les objets ayant des comportements asynchrones.
Par exemple, on peut annoter qu'un élément se met à jour de manière
autonome.

On peut associer un ensemble de propriétés par exemple la valeur minimale
ou maximale que l'on doit remplir dans un champs de saisi \emph{aria-valuemin,
aria-valuemax.}


\subsection{Discussion}

L'étude ci-dessus présente de manière sommaire les éléments de langage
de HTML 4, 5 et ARIA. Au regard de notre problématique, nous pouvons
voir quelques perspectives à la conception d'un méta-modèle.

HTML 4 fournit une sémantique riche pour décrire les élements textuels
d'une page et ses hyperliens. En effet il y a pléthore d'éléments
pour structurer un paragraphe. Cependant le mécanisme de structuration
fournit est trop générique et ambiguie. 

HTML 5 semble combler ces limites en apportant de nouveaux éléments
lexicaux amenant une sémantique plus riche sur la structure d'une
page et ses élements. La norme 5 introduit également des balises pour
la description d'élément propre à une page web comme des menus de
navigation, bannière, logo, etc...

La norme ARIA intégre plus d'élements pour décrire une page web et
notament une description du comportement des éléments d'une page web
particulierement utiles avec le développement des éléments graphiques
appelés widget.

Un méta-modèle basé sur la syntaxe de HTML 5 semble être un compromis
intéressant entre HTML 4 et ARIA. \emph{En effet HTML 4 est peu adapté
à l'expression de transformation, alors que ARIA est trop riche au
regard de nos besoins. }

\newpage


\section{Extraction de structure (Reconstruction d'architecture?)\label{sec:Extraction-de-structure}}


\subsection{Introduction}

L'extraction est la première phase du processus de restructuration.
On peut la décrire comme le processus de décourverte des éléments
d'un tout. Les éléments à extraire de la page correspondent aux différentes
briques conformes aux éléments d'un méta-modèle de page définit à
priori. La problématique est dûe au langage de conception des pages
web qui manque de sémantique, rendant un processus d'extraction automatique
difficile.

La conception des pages web s'articule autour : d'un langage pour
décrire la structure du document (HTML) et d'un langage pour décrire
la mise en forme du document (CSS). Les pages sont constituées d\textquoteright{}éléments
hétérogènes : une page est constituée d'un ou plusieurs contenu principal,
d'un menu de navigation, de publicité, etc... Chacun de ces éléments
représentent une sous-structure de la page. Lorsqu'on regarde une
page web depuis un navigateur, on constate que ces éléments sont structurés
de façon sémantique, ils sont organisés selon leur sens. La difficulté
dans la tâche d'extraction de la structure d'une page est dûe au manque
d'expressivité du HTML. En effet, la norme actuelle de HTML (HTML
4), ne fournit pas de moyen de délimiter les éléments du document
en fonction de leur sémantique. Par exemple, on ne peut pas délimiter
de manière explicite la structure d'un menu dans une page avec ce
langage. Le constat est que l'information de la structure d'une page
apparaît principalement dans la mise en page. La structure d'une page
est explicitée à travers l'utilisation de police, de couleur ou plus
généralement d\textquoteright{}éléments visuels pour caractériser
les contenus qui ont la même signification.

Les approches étudiées dans la tâche d'extraction de la structure
commence par une phase de segmentation. Cette étape permet de découper
une page en région. On peut ainsi délimiter son contenu de façon explicite.
Puis une phase de compréhension de contenu afin d'identifier le rôle
de chaque région dans une page.


\subsection{Segmentation de contenu}


\subsubsection{Approche segmentation visuelle}

L'approche proposée par les auteurs \cite{cai2003extracting} présente
un algorithme de partitionnement basé sur les éléments de mise en
forme des pages web. Le partionnement extrait une structure qui regroupe
les éléments d'une page sémantiquement proche en bloc (e.g figure
\ref{vips_partitionnement}). Le postulat est que les éléments d'une
page possédant des caractéristiques de mise en forme proche, tels
que la police, la couleur, la taille, sont sémantiquement proches.

\begin{figure}[H]
\centering
\includegraphics[width=300px]{img/VIPS-partionnement.jpg}

\caption{Exemple de partionnement, (a) page (b) DOM de la page\label{vips_partitionnement}}
\end{figure}


L'algorithme exploite le DOM%
\footnote{Document Object Model%
} de la page web. Le DOM est une API%
\footnote{Application Programming Interface%
} pour les documents HTML (ou plus généralement XML) . Il fournit une
représentation arborescente d'un document et les moyens d'accéder
à son contenu et sa mise en forme. 

Le processus de segmentation, figure \ref{vips-process}, se décompose
en trois phases : un processus d'extraction de blocs, un processus
de détection de séparateur et un processus de reconstruction. 

Le processus d'extaction détecte les éléments du niveau courant du
DOM succeptibles de former un contenu cohérent. Cette détection repose
sur des séparateurs explicites : on sait que certains éléments délimitent
le contour d'un contenu (par exemple les balises <DIV>). Mais également
sur une fonction de distance visuelle comparant les noeuds parents
et frères du noeud courant : une balise <DIV> a de grande chance de
délimiter un contenu sémantiquement différent du noeud parent si la
couleur de fond est différente de celle de ce dernier. Pour chaque
noeud, l'algorithme vérifie s'il forme un bloc ou non. Si oui, il
associe un degré de cohérence au bloc. Ce degré de cohérence est un
indicateur de l'importance sémantique du bloc. Si non, il est appliqué
le même processus aux enfants du noeud. Quand tous les noeuds du bloc
courant sont extraits, ils sont mis dans un pool. 

Des séparateurs entre les blocs sont ensuite detectés. L'algorithme
dététecte ici des séparateurs implicites, c'est à dire n'apparaîsant
pas dans la structure HTML. Les séparateurs implicites sont les espaces
entre les blocs d'un pool. Un poid est attribué à chaque séparateur
suivant son importance (par exemple, plus l'espacement entre deux
blocs est grand, plus le poid sera élevé). Ce poid est un indicateur
de différence sémantique entre les blocs adjacents. Plus le poid du
séparateur est élevé entre deux blocs, plus leur contenu sera sémantiquement
éloigné.

Une construction hiérachique des blocs est crée. Cette construction
hiérachique repose sur le degré de cohérence attribué à chaque bloc. 

Pour chaque nouveau bloc de la structure hiérarchique construite,
l'algorithme teste le degré de cohérence attribué par rapport à un
seuil de cohérence défini. Ce seuil est défini suivant la granularité
de la structure que l'on veut en sortie de l'algorithme. Si le degré
de cohérence n'est pas supérieur au seuil de cohérence, le bloc est
de nouveau partionné. La structure finale est construite après que
tous les blocs soient traités. 

\begin{figure}[H]
\centering
\includegraphics[width=300px]{img/VIPS-processus.jpg}

\caption{Algorithme de segmentation \label{vips-process}}
\end{figure}



\subsection{Compréhension de contenu}


\subsubsection{Analyse syntaxique}


\paragraph{Similarité de séquence}

L'un des postulats de base en bioinformatique est qu'une séquence
génomique similaire donne une protéine présentant la même fonction.
En d'autre terme, des séquences ayant des similitudes (syntaxiques)
est un signe de proximité fonctionnelle. Appliqué à une page web,
cela signifie que par exemple la structure syntaxique d'un menu d'une
page web A est similaire à la structure syntaxique d'une page web
B. Il semble cohérent d'appliquer ce postulat à une page web. En effet,
la publication de contenu sur le web se standardise par l'intermédiare
des scripts. Ceux-ci générent des pages de manière automatique et
standardisée (Wordpress, joomla, etc). Afin d'obtenir un bon référencement,
les moteurs de recherche insitent les auteurs de page web d'adopter
des normes de conception. En construisant une séquence représentative
d'un élément de notre méta-modèle, il devrait être possible de déterminer
la fonction d'un fragment de page web. Pour déterminer la similarité
de deux séquences, les bioinformaticiens utilisent le concept du coût
d'alignement.
\begin{defn*}
L' alignement est la mise en correspondance de deux séquences. Soit
deux séquences X1:n et Y1:m dont la valeur est définie dans le même
alphabet fini $\Lambda$. Un alignement est une correspondance entre
les lettres de la première séquence et celles de la deuxieme, sans
en changer l'ordre, et en autorisant eventuellement des « trous ».
\end{defn*}
\begin{figure}[H]
\centering

G A A T C \_ T G A C

C A \_ \_ C G T \_ A \_

\caption{Alignement possible des sequences X1=GAATCTGAC,Y1=CACGTA}
\end{figure}


~\\La mise en correspondance repose sur trois types d'opérations
élementaires : la substitution, l'insertion, deletion. Plusieurs combinaisons
d'alignements existent. Lorsque l'on souhaite comparer la similitude
de deux séquences, la meilleure solution est celle qui minimise le
nombre d'opérations d'insertions et de deletions.

\begin{figure}[H]
\centering
\includegraphics[width=300px]{img/operation_alignement_sequence.jpg}

\caption{opérations d'alignements}
\end{figure}


Il existe deux types d'alignements : local et global. 


\subparagraph{L'alignement global }

L'alignement global est conçu pour comparer des séquences sur toute
leur longueur. Une méthode optimale pour trouver un alignement global
maximal de chaîne de caractères est l'algorithme de Needleman-Wunsch
\cite{needleman1970general}. 


\subparagraph{L'alignement local }

L'alignement local est conçu pour rechercher dans la séquence A des
régions semblables à la séquence B (ou à des parties de la séquence
B). Une méthode pour trouver un alignement local maximal de chaîne
de caractères est l'algorithme de Smith \& Waterman \cite{smith1981identification}. 

~\\

\begin{figure}[H]
\centering
\includegraphics[width=200px]{img/Global-local-alignment.png}

\caption{Comparaison sequence d'alignement globale et locale\label{comp-align}}
\end{figure}


Comme on le voit dans la figure \ref{comp-align} l'alignement global
tente d'aligner les séquences sur toute leur longueur, tandis que
l'alignement local se focalise sur les zones de forte homologie. L'alignement
global est adapté à la comparaison de deux fragments de taille approximativement
égales. Alors que l'alignement local, permet de faire correspondre
un fragment dans une plus grande séquence.


\paragraph{Similarité d'arbre}

Une autre approche dans l'etude de similarité de structure est la
comparaison d'arbre. Cette approche consiste à trouver la plus petite
ou la moins coûteuse séquence d'opération d'édition (substitution,
suppression et insertion) qui permet la transformation d'un arbre
vers un autre. 

Notons $\Lambda$ un noeud vide. Une opération d'édition est écrite
$b\rightarrow c$ , où b et c sont soit un noeud, soit $\Lambda$
. 
\begin{itemize}
\item $b\rightarrow c$ est une opération de substition si $b\neq\Lambda$
et $c\neq\Lambda$, 
\item une opération de suppression si $b\neq\Lambda\doteq c$, 
\item une opération d'insertion si $b=\Lambda\neq c$
\end{itemize}
Pour exprimer une séquence d'opération élémentaire qui transforme
l'arbre, on utilise le concept de mapping, introduit \cite{tai1979tree}.
Un mapping établie une correspondance un-à-un entre les n½uds de deux
arbres ordonnés et qui préservent l'ordre des n½uds. 

~\\
\begin{defn*}
Un Mapping $M$ de l'arbre T1 vers l'arbre T2 est un ensemble de paire
ordonnée d'entier (i, j), $1\leqslant i\leqslant n1$, $1\leq j\leq n2$,
satisfaisant les conditions suivantes, pour tous $(i1,j1),(i2,j2)\in M$:\end{defn*}
\begin{itemize}
\item i1=i2 si et seulement si, j1=j2 (one-to-one condition);
\item t1{[}i1{]} est à droite de t1{[}i2{]}, si est seulement si, t2{[}j1{]}
est à droite de t2{[}j2{]} (préservation de l'ordre des noeuds frères);
\item t1{[}i1{]} est un ancêtre de t1{[}i2{]} si et seulement si, t2{[}j1{]}
est un ancêtre de t2{[}j2{]} (préservation de l'ordre des ancêtres);
\end{itemize}
~\\
\begin{defn*}
Soit M un mapping entre les arbres T1 et T2 décrivant des opérations
de modification. S est l'ensemble de pair $(i,j)\in M$, D l'ensemble
des n½uds T1{[}i{]} n'ayant pas de paire $(i,j)\in M$ , et I l'ensemble
des n½uds T2{[}j{]} n'ayant pas de paire $(i,j)\in M$. Le coût du
mapping est donné par $|S|p+|I|q+|D|r$| , où p est le coût des substitutions
non identiques, q est le coût des insertions (1), r est le coût d'une
suppression (1), le coût des substitutions identiques est 0. ~\\
\end{defn*}
Pour connaître la similarité entre deux structures, on veut calculer
une distance d'alignement. C'est à dire trouver le coût minimum du
mapping pour que T1 et T2 soient isomorphes. KUO-CHUNG TAI \cite{tai1979tree}
propose un algorithme de programmation dynamique pour résoudre la
question de distance d'arbre en temps séquentiel $O(|T1|\times|T2|\times min(depth(T1),leaves(T1))\times min(depth(T2),leaves(T2)))$
.


\subsubsection{Analyse fonctionnelle}

Pour connaître le rôle de chaque élement, \cite{chen2001function}
propose une approche basée sur une analyse fonctionnelle de ces derniers.
Pour cela les auteurs proposent un modèle : Function-based object.
Ce modèle considère chaque élément d'une page comme un objet ayant
des propriétés,tel que la valeur de ces propriétés définit le rôle
de l'objet. Les principales propriétés sont basées sur la présentation
(type de média, agencement, etc), les hyperliens (le nombre d'hyperlien?
vers où pointent ils?), l'interaction avec l'utilisateur (uniquement
affichage, soumission de contenu?). L'extraction des propriétés fonctionnelles
sont faites principalement par analyse de la nature des balises et
les attributs associés aux balises. Suivant la valeur des propriétes,
les objets sont rangés dans différentes catégories : objet de type
informatif, de navigation, d'interaction, de décoration, etc. L'analyse
de la catégorie d'un objet se fait au moyen d'un arbre de décision
(e.g figure \ref{arbre_decision}). Les principales catégories (rôle)
des objets.

\begin{figure}[H]
\centering
\includegraphics[width=200px]{img/arbre_decision.jpg}

\caption{Exemple d'arbre de décision basique\label{arbre_decision}}
\end{figure}



\subsection{Discution}

(alignement global) La méthode de segmentation visuelle (section précedente)
semble pouvoir extraire et regrouper les éléments sémantiquements
proche d'une page. L'inconvénient est que l'on ne connait pas la signification
de ses élements. Une approche serait de construire une séquence reprensentative
d'un élement de notre méta-modèle et de comparer les sequences extraites
d'une page aux sequences associée au méta-modèle. 

(alignement local) Cette approche ne necessite pas d'extraire de sequences
dans le une page. On peut comparer directement une sequence du meta-modele
à la page pour trouver la zone qui correspond.

\newpage


\section{Conclusion}

\newpage

\bibliographystyle{plain}
\bibliography{bibliographie/biblio}

\end{document}
